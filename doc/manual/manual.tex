\mainlanguage[en]
% enable hyperlinks, don't give them a different color, don't automatically switch to "fit page" mode when clicking a
% link
\setupinteraction[state=start,color=,contrastcolor=,focus=standard]
% automatically create bookmarks for the items in the first argument, automatically expand the tree for the items in the
% second argument.
\placebookmarks[chapter,section,subsection][chapter,section]
% expand macros in titles used in bookmarks
\enabledirectives[references.bookmarks.preroll]
% TODO add document metadata to PDF (title, author, â€¦)
\setuplanguage[en][spacing=packed]
\setuppapersize[A4]
\setuphead[chapter][style=\bfc]
% Place an empty line between paragraphs
\setupwhitespace[line]

\definecolor[stateActive][x=448844]
\definecolor[stateBlockedGC][x=9C6FD6]
\definecolor[stateBlockedHappensBefore][x=BB6363]
\definecolor[stateBlockedNet][x=BB5D5D]
\definecolor[stateBlockedSyscall][x=BA4F41]
\definecolor[stateBlocked][x=BA4141]
\definecolor[stateGC][x=9C6FD6]
\definecolor[stateInactive][x=888888]
\definecolor[stateReady][x=4BACB8]
\definecolor[stateStuck][x=000000]

\define[2]\traceState{\inframed[background=color,backgroundcolor=#2]{#1}}

\definemargindata[intodo][right][margin=margin,width=\rightmarginwidth,align=flushleft,color=red,style=]

\definestartstop[todo][color=red]

\define[1]\code{{\tt\unhyphenated{#1}}}


\definefontfeature[default][default][expansion=quality,protrusion=quality]
\usetypescript[modern-base]
% Make sure to use setupbodyfont after definefontfeature so the features actually get used
\setupbodyfont[modern,12pt]
\setupalign[hz,hanging]

\showframe

\starttext

% TODO(dh): add a title page.

\intodo{Most of these titles are placeholders, as is the overall structure}
\completecontent

\startchapter[title=\todo{Something about our UI}]
  \startsection[title=Color coding]
  \stopsection

  \startsection[title=Middle click]
  \stopsection

  \startsection[title=Goroutine states]
    \starttodo
    Something about how a goroutine will be in one of several states.
    States have colors, some of them have labels, different labels at different zoom levels.
    \stoptodo

    Some of these states are actual states in the Go runtime, while other states are introduced by gotraceui to increase
    the level of detail.

    \startitemize
    \item \traceState{created}{stateReady} Newly created goroutines will be in this state before they get scheduled for the first time.
      It is a special case of the ready state.

    \item \traceState{active}{stateActive} Active goroutines are those that are currently running.

    \item \traceState{send}{stateBlockedHappensBefore}, \traceState{recv}{stateBlockedHappensBefore},
      \traceState{select}{stateBlockedHappensBefore} These states describe the three ways in which goroutines can be blocked on channel communication.

    \item \traceState{sync}{stateBlockedHappensBefore} This state is used by goroutines that are blocked on sync primitives, such as \code{sync.Mutex}.

    \item \traceState{sync.Once}{stateBlockedHappensBefore} Blocked on a \code{sync.Once}.
      This is a special case of the sync state and detected by gotraceui based on stack traces.

    \item \traceState{sync.Cond}{stateBlockedHappensBefore} Blocked on a condition variable (\code{sync.Cond}.)

    \item \traceState{I/O}{stateBlockedNet} This state is entered by goroutines that are waiting for pollable I/O to complete.
      See \about[netpoller] for more information.

    \item \traceState{syscall}{stateBlockedSyscall} Goroutines enter this state when they invoke a blocking syscall.
      See \about[syscalls] for an explanation of the difference between blocking and non-blocking syscalls in the context of Go.

    \item \traceState{blocked}{stateBlocked} Blocked goroutines are waiting for something to happen, but we don't know what.
      This usually happens for goroutines of the runtime that don't emit more accurate information.
      User goroutines will usually have more specific states such as \quote{send}.

    \item \traceState{inactive}{stateInactive} This state is one of gotraceui's custom states and is used for
      goroutines that are blocked or ready to run, but aren't actually eager to run.
      For blocked goroutines, this is exclusively used by goroutines of the runtime that block on some lock to pace the amount of work they do.
      Goroutines that are technically in the ready state but are marked inactive are those that called runtime.Gosched or time.Sleep,
      as this indicates that they willingly gave up part of their share in CPU time, and their time spent waiting shouldn't be considered scheduler latency.

      \intodo{We still need to describe this state}
    \item \traceState{BlockedGC}{stateGC}

    \item \traceState{ready}{stateReady} A goroutine in this state isn't blocked on anything anymore and can start running as soon as it gets scheduled.
      A goroutine can be in this state because there aren't any free Ps to run it,
      or simply because the scheduler hasn't gotten around to starting it yet.
      Goroutines can transition into this state from the active state if they get preempted,
      or from any of the various blocked states once they get unblocked.
      Time spent in this state is commonly called scheduler latency.

      \intodo{We still need to describe these states}
    \item \traceState{GC (idle)}{stateGC}

    \item \traceState{GC (dedicated)}{stateGC}

    \item \traceState{GC mark assist}{stateGC} Goroutines in the \quote{GC mark assist} state are assisting the mark phase.
      See \about[gc] to learn more about the garbage collector.

    \item \traceState{GC sweep}{stateGC} Goroutines in the \quote{GC sweep} state are sweeping memory.
      See \about[gc] to learn more about the garbage collector.

      \intodo{Drawing black on black isn't brilliant}

    \item \traceState{stuck}{stateStuck} Goroutiens in this state are stuck and can never make progress.
      This happens, for example, when receiving from a nil channel or using \code{select} with no cases.

    \stopitemize


  \stopsection

  \startsection[title=Tags]
    Gotraceui will annotate spans with tags, which further describe the states goroutines are in.
    These tags are produced by automatically parsing stack traces,
    and for example deducing that a goroutine that's blocked on pollable I/O got to that state by making a TLS-encrypted HTTP request over TCP,
    which provides a lot more information than just \quotation{I/O}.

    Being based on stack trace parsing, tags are provided on a best-effort basis.
    Without a matching, hand-written pattern, tags will not be recognized.
    The author of the software adds new patterns as he notices them and tries to keep them in sync with new releases of Go.

    The following tags exist:

    \startitemize
    \item HTTP, for I/O related to HTTP
    \item TCP, for I/O related to TCP
    \item TLS, for I/O related to TLS
    \item accept, for blocking on \goto{accept(2)}[url(https://man7.org/linux/man-pages/man2/accept.2.html)]ing on a network connection
    \item dial, for blocking on dialing a network connection
    \item network, for network I/O
    \item read, for read I/O
    \stopitemize
  \stopsection
\stopchapter

\startchapter[title=The \code{runtime/trace} package]
  \startsection[title=Adding tracing to your application]
    \todo{TODO}
  \stopsection

  \startsection[title=User annotations]
    \todo{TODO}
  \stopsection

  \startsection[title=\todo{Tracing in tests or something}]
    \todo{TODO}
  \stopsection

\stopchapter

\startchapter[title=Understanding the Go runtime]

  \startsection[title=Introduction]
    \todo{TODO}
  \stopsection

  \startsection[title=The scheduler]
    Go programs can have very many goroutines, up to millions.
    Because it wouldn't be feasible to map one goroutine to one OS level thread,
    Go has to distribute goroutines over a smaller number of threads.
    To do so, the scheduler has to decide which goroutines to run when,
    part of which involves tracking which goroutines {\em can} run.
    The activity related to this makes up a large part of what the runtime trace captures and gotraceui visualizes.
    It is thus helpful to understand how the scheduler works.

    \startsubsection[title={Ms, Ps, and Gs}]
      \starttodo
      M = OS threads
      P = token/internal state, GOMAXPROCS of them
      G = goroutines

      Many Gs run on many Ms, at most len(P) of them. Blocking syscalls etc get their own M.

      LockOSThread locks a G to an M; it's still free to jump between Ps.

      https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit
      https://morsmachine.dk/go-scheduler
      \stoptodo
    \stopsubsection

    \startsubsection[title=Syscalls,reference=syscalls]
    \todo{TODO}
    \stopsubsection

    \startsubsection[title=Gosched]
    \todo{TODO}
    \stopsubsection

    \startsubsection[title=Pollable vs. unpollable I/O,reference=netpoller]
    \todo{TODO}
    \stopsubsection
  \stopsection

  \startsection[title=Garbage collection,reference=gc]
    Go uses a concurrent mark and sweep garbage collector.
    Its activity will interact with the scheduling of your goroutines in various ways,
    which we'll explore in this section.
    We will focus on the details that matter for understanding runtime traces.
    There are many more details to how the GC works and you're encouraged to read the \goto{official documentation}[url(https://go.dev/doc/gc-guide)] to learn more about it.

    \startsubsection[title=\todo{Something about mark, sweep, mark assist, STW, how GC gets triggered, etc}]
    \stopsubsection
  \stopsection

  \startsection[title=The runtime's goroutines]
    The runtime spawns several of its own goroutines that will show up in most traces.
    Most of these exist to help with the concurrent garbage collector.

    \startitemize
    \item \code{bgsweep} is a low priority goroutine that sweeps spans when there are idle Ps. This reduces the amount
      of sweeping that has to be done by other goroutines.
    \item \todo{bgscavenger}
    \item \todo{gcBgMarkWorker}
    \item \code{forcegchelper} periodically gets woken up and forces a garbage collection cycle to start.
      This ensures that garbage gets collected regularly even if the program isn't allocating enough memory to hit the heap target.
    \item \code{runfinq} is the goroutine that is responsible for running finalizers.
      That means that this runtime goroutine will execute code provided by the user via \code{runtime.SetFinalizer}.
    \stopitemize

  \stopsection

  \stopchapter

  \startchapter[title=Stack trace timeline]

    In addition to sequences of runtime events and user regions, gotraceui can also display timelines of stack traces.
    Such timelines can help spot macroscopic patterns in code execution. They are reconstructed from CPU profiling
    samples as well as the stacks associated with certain runtime events and thus have a sampled, imprecise nature.

    \midaligned{\clip[width=0.95\textwidth]{\externalfigure[stack_samples.png]}}

    It is important to understand the nature and limitations of the data displayed in these timelines. Strictly
    speaking, each CPU profiling sample and each runtime event describes an instant in time, not a duration. However, in
    our reconstruction, we connect consecutive stack traces, making it look like a function has been running for the
    entire duration between two events or samples. This is a lie.

    A CPU profiling sample states that at a specific point in time, a certain function was executing. It doesn't say
    anything about what happened right after the sample. By default, samples occur at a frequency of 100 \unit{Hz}, i.e.
    once every 10 \unit{ms}. This means that there is 10 \unit{ms} of uncertainty after a sample. The function might've
    returned anywhere from 0 to 10 \unit{ms} after the sample. It may even have been called repeatedly. All we really
    know is that at one point in time, the function was running.

    Nevertheless, when looking at larger scales (hundreds of milliseconds, if not seconds), especially when looking at
    repetitive executions, this visualization can expose patterns. The more often the same stack gets sampled, the more
    likely it is that it is indeed a major contributor to the code's execution. However, the data is woefully inadequate
    at small scales â€” the kind of scales at which runtime trace data exists. You shouldn't rely on the sampled stack
    traces to fill in the gaps between two runtime events that happened 100 \unit{us} apart.

    Gotraceui combines both CPU profiling and some runtime events when reconstructing a stack trace timeline. CPU
    samples are those used by pprof. Beginning with Go 1.19, runtime traces include CPU samples if profiling is enabled
    at the same time as tracing. However, goroutines that are blocked don't receive any samples, so we additionally use
    the stacks associated with runtime events that signal state transitions, such as goroutines calling
    \code{time.Sleep}, to fill in the gaps. This way, the last stack before a potentially long time without samples will
    be as accurate as possible.

    Using sampling and runtime events together further affects how you should treat durations in the stack trace
    timeline because of the following two reasons:

    \startitemize[n]
    \item We've already established that span durations derived from samples aren't accurate, but this is even more
      pronounced when trying to look at runtime events and the corresponding reconstructed timeline together. For
      example, when we enter the \quote{blocked on channel send} state, we will display the stack associated with that
      event, until we get the next stack. This means, however, that even after we unblock and go back to the
      \quote{ready} and \quote{active} states, the stack will not update, as neither event contains a new stack. This
      will make it look like we're still in the \code{runtime.chansend} function even after we've completed the channel
      send. Only on the next sample or relevant event will the stack update. It is therefore important to either look at
      runtime events or the stacks, but not both together. Runtime events show an exact history of what happened in
      the runtime, while stacks show a guess at what happened in user code.

    \item CPU profiling samples happen at a fairly constant rate, which means all samples have the same uncertainty.
      Runtime events, however, can happen at arbitrary points. If a sample is followed by a runtime event 1 \unit{ms}
      later then it will look much smaller than if it were followed by a runtime event 9 \unit{ms} later, even though in
      the latter case we still don't know what happened for the first 9 \unit{ms}. This is another instance of span
      durations of samples not having much meaning.
    \stopitemize

    Gotraceui doesn't use the stacks of other events, such as syscalls, because this would lead to bias in the data.
    Samples are evenly distributed and â€“ on average â€“ lead to a fair representation of a program's execution, and
    considering state transitions is necessary, as we have explained earlier. Including other events, on the other hand,
    would skew the displayed stacks towards those events.
  \stopchapter

\stoptext
