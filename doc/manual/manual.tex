\mainlanguage[en]
% enable hyperlinks, don't give them a different color, don't automatically switch to "fit page" mode when clicking a
% link
\setupinteraction[state=start,color=,contrastcolor=,focus=standard]
% automatically create bookmarks for the items in the first argument, automatically expand the tree for the items in the
% second argument.
\placebookmarks[chapter,section,subsection][chapter,section]
% expand macros in titles used in bookmarks
\enabledirectives[references.bookmarks.preroll]
% TODO add document metadata to PDF (title, author, …)
\setuplanguage[en][spacing=packed]
\setuppapersize[A4]
\setuphead[chapter][style=\bfc]
% Place an empty line between paragraphs
\setupwhitespace[line]

\definecolor[stateActive][x=448844]
\definecolor[stateBlockedGC][x=9C6FD6]
\definecolor[stateBlockedHappensBefore][x=BB6363]
\definecolor[stateBlockedNet][x=BB5D5D]
\definecolor[stateBlockedSyscall][x=BA4F41]
\definecolor[stateBlocked][x=BA4141]
\definecolor[stateGC][x=9C6FD6]
\definecolor[stateInactive][x=888888]
\definecolor[stateReady][x=4BACB8]
\definecolor[stateStuck][x=000000]
\definecolor[stateMerged][x=B9BB63]
\definecolor[stateUserRegion][x=F2A2E8]
\definecolor[stateSample][x=79B579]

\define[2]\traceState{\inframed[background=color,backgroundcolor=#2]{#1}}

\definemargindata[intodo][right][margin=margin,width=\rightmarginwidth,align=flushleft,color=red,style=]

\definestartstop[todo][color=red]

\define[1]\code{{\tt\unhyphenated{#1}}}

\define[1]\noun{{\em#1}}
% XXX somehow style keys and menus
\define[1]\key{#1}
\define[1]\menu{#1}

\definefontfeature[default][default][expansion=quality,protrusion=quality]
\usetypescript[modern-base]
% Make sure to use setupbodyfont after definefontfeature so the features actually get used
\setupbodyfont[modern,12pt]
\setupalign[hz,hanging]

\showframe

\starttext

% TODO(dh): add a title page.

\intodo{Most of these titles are placeholders, as is the overall structure}
\completecontent

\todo{This manual needs a proper structure. Something along the lines of quick start, an introduction to Gotraceui (i.e.
  a feature overview and why it exists), how to set up tracing in all its details, how to analyze the data.}

\startchapter[title=Introduction]
  Gotraceui is a tool for visualizing and analyzing Go execution traces.
  It is meant to be a faster, more accessible, and more powerful alternative to \code{go tool trace}.
  Unlike \code{go tool trace}, Gotraceui doesn't use deprecated browser APIs (or a browser at all),
  and its UI is tuned specifically to the unique characteristics of Go traces.
\stopchapter

\startchapter[title=Quickstart]
\stopchapter

\startchapter[title=System requirements]
  Gotraceui runs on Linux (X11 and Wayland), Windows, and macOS.

  Runtime traces are very dense in information and can contain millions of events in the span of seconds.
  The format emitted by \code{runtime/trace} is optimized for small and low overhead output and is highly compressed.
  To be able to process and display a trace, Gotraceui has to parse and materialize it in memory.
  Memory usage is roughly 30x the size of the input trace.
  That is, a \unit{300 MB} trace file will need about \unit{9 GB} of memory to be loaded by Gotraceui.
  For reference, an example \unit{300 MB} trace file was produced by tracing a busy Prometheus instance for one minute, resulting in \unit{66,044,021} events.
  This represents an extreme example.
  Many of your traces will be much smaller than that.
  For example, tracing \code{net/http}'s tests produces a \unit{7.3 MB} trace instead, 
\stopchapter


\startchapter[title=The user interface]
  The following sections will describe the various components of Gotraceui's UI.

  \startsection[title=Main window]
    The main window displays a main menu and an interactive \noun{canvas} representing the trace data.

    \midaligned{{\externalfigure[images/screenshots/main_window.png][width=0.95\textwidth]}}

    The canvas can be moved around by dragging with \key{LMB} or by scrolling.
    Holding \key{Ctrl/Cmd} while scrolling zooms in and out, centered around the cursor's position.
    Dragging with \key{Ctrl/Cmd}+\key{LMB} selects a region of time to zoom to.
    The \menu{Display} menu contains commands for changing the way \noun{timelines} are displayed on the canvas, as well as commands for quick navigation.

    \startsubsection[title=Axis]
      The top of the window shows the \noun{axis}.

      \midaligned{{\externalfigure[images/screenshots/axis.png][width=0.95\textwidth]}}

      The leftmost tick displays the absolute time at that point in the trace.
      Subsequent ticks show increments relative to this absolute time.
      For example, the screenshot shows an axis that starts at \unit{2,626,835,792 ns} and where each major tick represents an increase of \unit{1 ms}.
      \intodo{talk about negative absolute ticks}

      Additionally, the axis contains red and purple sections, which correspond to the garbage collector's stop-the-world phase and general activity.
      Pressing \key{O} cycles through displaying the red section, both sections, or none of the sections across the entire canvas.
    \stopsubsection

    \startsubsection[title={Timelines, tracks, and spans}]
      The canvas consists of a number of horizontally stacked timelines.
      A timeline might show a processor, a goroutine, or phases of the garbage collector.
      Every timeline has a label, hovering over which may display a tooltip.

      \midaligned{{\externalfigure[images/screenshots/processor-tooltip.png][width=0.5\textwidth]}}

      For example, for processors, the tooltip will show how much time was spent executing user code, doing garbage collection work, and being idle.
      Pressing \key{Ctrl/Cmd}+\key{LMB} on a label will zoom the canvas such that all spans in that timeline are visible.
      Pressing \key{LMB} on a goroutine label will open the corresponding goroutine window. You can read more about goroutine windows in \about[goroutine-windows].

      A timeline consists of one or more horizontally stacked \noun{tracks}.

      \midaligned{{\externalfigure[images/screenshots/activity.png][width=0.95\textwidth]}}

      For example, the screenshot shows a goroutine timeline with six tracks.
      The first track contains the runtime tracing information, while the other five tracks represent the five levels of call stacks acquired via CPU sampling.
      See \about[cpu-sampling] for more information on the specifics of CPU sampling in Gotraceui.
      Another source of tracks is code that is annotated with user regions.

      Each track consists of a series of \noun{spans}.
      A span represents a state for some duration of time.
      For example, a goroutine may be blocked on a channel send operation for \unit{100 ms}, and this would be displayed as a single span.
      Hovering over a span will show context-specific information about it, including its state and duration, but also additional information such as tags \intodo{(link to the section on tags}) or the reason for being in a certain state.
      Pressing \key{Ctrl/Cmd}+\key{LMB} on a span will zoom the canvas such that the span is fully visible.

      Spans have different colors depending on the states they represent.
      Different kinds of timelines and tracks may use different color schemes.
      \intodo{link to where the color schemes are documented}

      Depending on the zoom level, individual spans may be too small to display.
      Gotraceui uses two strategies to ensure that spans are always visible.
      First, it merges consecutive tiny spans, displaying them as one big span instead. Such merged spans get their own color \intodo{(which? also explain gradients)}.
      Zooming into merged spans unmerges them.
      Second, if there aren't enough spans to merge, the span is given a minimum size. \intodo{mention how that means following spans might be rendered smaller than they are, and that zooming into an enlarged span may not change its size for quite a while.}

      \startsubsubsection[title={Span colors}]
        Spans in processor timelines will have one of two colors:
        \traceState{Green}{stateActive} for spans that represent running user goroutines,
        and \traceState{purple}{stateGC} for spans that represent garbage collection work.

        Spans in the first track of goroutine timelines can have many different colors, representing the many different states a goroutine can be in.
        You can find an exhaustive list of all goroutine states – and the corresponding span colors – in \about[goroutine-states].

        User regions are displayed in \traceState{light pink}{stateUserRegion}. CPU samples are displayed in \traceState{light green}{stateSample}.

        When small spans get merged, they will be displayed in one of two ways:
        if all merged spans have the same state, then we will display a gradient from \traceState{light yellow}{stateMerged} to the color of the merged spans.
        For merged spans with mixed states, a solid light yellow is shown instead.
      \stopsubsubsection
    \stopsubsection

    \intodo{talk about context menu}
  \stopsection

  \startsection[reference=goroutine-windows, title=Goroutine windows]
    \startitemize
    \item \todo{General information}
    \item \todo{Stack trace}
    \item \todo{Per-state statistics}
    \item \todo{Events}
    \stopitemize
  \stopsection
  \startsection[title=Processor windows]
    \todo{TODO}
  \stopsection
  \startsection[title=Heatmaps]
    \todo{TODO}
  \stopsection
\stopchapter

\startchapter[reference=goroutine-states, title=Goroutine states]
  \starttodo
    Something about how a goroutine will be in one of several states.
    States have colors, some of them have labels, different labels at different zoom levels.
  \stoptodo

  Some of these states are actual states in the Go runtime, while other states are introduced by Gotraceui to increase
  the level of detail.

  \startitemize
  \item \traceState{created}{stateReady} Newly created goroutines will be in this state before they get scheduled for the first time.
    It is a special case of the ready state.

  \item \traceState{active}{stateActive} Active goroutines are those that are currently running.

  \item \traceState{send}{stateBlockedHappensBefore}, \traceState{recv}{stateBlockedHappensBefore},
    \traceState{select}{stateBlockedHappensBefore} These states describe the three ways in which goroutines can be blocked on channel communication.

  \item \traceState{sync}{stateBlockedHappensBefore} This state is used by goroutines that are blocked on sync primitives, such as \code{sync.Mutex}.

  \item \traceState{sync.Once}{stateBlockedHappensBefore} Blocked on a \code{sync.Once}.
    This is a special case of the sync state and detected by Gotraceui based on stack traces.

  \item \traceState{sync.Cond}{stateBlockedHappensBefore} Blocked on a condition variable (\code{sync.Cond}.)

  \item \traceState{I/O}{stateBlockedNet} This state is entered by goroutines that are waiting for pollable I/O to complete.
    See \about[netpoller] for more information.

  \item \traceState{syscall}{stateBlockedSyscall} Goroutines enter this state when they invoke a blocking syscall.
    See \about[syscalls] for an explanation of the difference between blocking and non-blocking syscalls in the context of Go.

  \item \traceState{blocked}{stateBlocked} Blocked goroutines are waiting for something to happen, but we don't know what.
    This usually happens for goroutines of the runtime that don't emit more accurate information.
    User goroutines will usually have more specific states such as \quote{send}.

  \item \traceState{inactive}{stateInactive} This state is one of Gotraceui's custom states and is used for
    goroutines that are blocked or ready to run, but aren't actually eager to run.
    For blocked goroutines, this is exclusively used by goroutines of the runtime that block on some lock to pace the amount of work they do.
    Goroutines that are technically in the ready state but are marked inactive are those that called runtime.Gosched or time.Sleep,
    as this indicates that they willingly gave up part of their share in CPU time, and their time spent waiting shouldn't be considered scheduler latency.

    \intodo{We still need to describe this state}
  \item \traceState{BlockedGC}{stateGC}

  \item \traceState{ready}{stateReady} A goroutine in this state isn't blocked on anything anymore and can start running as soon as it gets scheduled.
    A goroutine can be in this state because there aren't any free Ps to run it,
    or simply because the scheduler hasn't gotten around to starting it yet.
    Goroutines can transition into this state from the active state if they get preempted,
    or from any of the various blocked states once they get unblocked.
    Time spent in this state is commonly called scheduler latency.

    \intodo{We still need to describe these states}
  \item \traceState{GC (idle)}{stateGC}

  \item \traceState{GC (dedicated)}{stateGC}

  \item \traceState{GC mark assist}{stateGC} Goroutines in the \quote{GC mark assist} state are assisting the mark phase.
    See \about[gc] to learn more about the garbage collector.

  \item \traceState{GC sweep}{stateGC} Goroutines in the \quote{GC sweep} state are sweeping memory.
    See \about[gc] to learn more about the garbage collector.

    \intodo{Drawing black on black isn't brilliant}

  \item \traceState{stuck}{stateStuck} Goroutiens in this state are stuck and can never make progress.
    This happens, for example, when receiving from a nil channel or using \code{select} with no cases.

  \stopitemize
\stopchapter

\startchapter[title=Tags]
  Gotraceui will annotate spans with tags, which further describe the states goroutines are in.
  These tags are produced by automatically parsing stack traces,
  and for example deducing that a goroutine that's blocked on pollable I/O got to that state by making a TLS-encrypted HTTP request over TCP,
  which provides a lot more information than just \quotation{I/O}.

  Being based on stack trace parsing, tags are provided on a best-effort basis.
  Without a matching, hand-written pattern, tags will not be recognized.
  The author of the software adds new patterns as he notices them and tries to keep them in sync with new releases of Go.

  The following tags exist:

  \startitemize
  \item HTTP, for I/O related to HTTP
  \item TCP, for I/O related to TCP
  \item TLS, for I/O related to TLS
  \item accept, for blocking on \goto{accept(2)}[url(https://man7.org/linux/man-pages/man2/accept.2.html)]ing on a network connection
  \item dial, for blocking on dialing a network connection
  \item network, for network I/O
  \item read, for read I/O
  \stopitemize
\stopchapter

\startchapter[title=The \code{runtime/trace} package]
  \startsection[title=Adding tracing to your application]
    \todo{TODO}
  \stopsection

  \startsection[title=User annotations]
    \todo{TODO}
  \stopsection

  \startsection[title=CPU profiling]
    \todo{TODO}
  \stopsection

  \startsection[title=\todo{Tracing in tests or something}]
    \todo{TODO}
  \stopsection
\stopchapter

\startchapter[title=Understanding the Go runtime]

  \startsection[title=Introduction]
    \todo{TODO}
  \stopsection

  \startsection[title=The scheduler]
    Go programs can have very many goroutines, up to millions.
    Because it wouldn't be feasible to map one goroutine to one OS level thread,
    Go has to distribute goroutines over a smaller number of threads.
    To do so, the scheduler has to decide which goroutines to run when,
    part of which involves tracking which goroutines {\em can} run.
    The activity related to this makes up a large part of what the runtime trace captures and Gotraceui visualizes.
    It is thus helpful to understand how the scheduler works.

    \startsubsection[title={Ms, Ps, and Gs}]
      \starttodo
        M = OS threads
        P = token/internal state, GOMAXPROCS of them
        G = goroutines

        Many Gs run on many Ms, at most len(P) of them. Blocking syscalls etc get their own M.

        LockOSThread locks a G to an M; it's still free to jump between Ps.

        https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit
        https://morsmachine.dk/go-scheduler
      \stoptodo
    \stopsubsection

    \startsubsection[title=Syscalls,reference=syscalls]
      \todo{TODO}
    \stopsubsection

    \startsubsection[title=Gosched]
      \todo{TODO}
    \stopsubsection

    \startsubsection[title=Pollable vs. unpollable I/O,reference=netpoller]
      \todo{TODO}
    \stopsubsection
  \stopsection

  \startsection[title=Garbage collection,reference=gc]
    Go uses a concurrent mark and sweep garbage collector.
    Its activity will interact with the scheduling of your goroutines in various ways,
    which we'll explore in this section.
    We will focus on the details that matter for understanding runtime traces.
    There are many more details to how the GC works and you're encouraged to read the \goto{official documentation}[url(https://go.dev/doc/gc-guide)] to learn more about it.

    \startsubsection[title=\todo{Something about mark, sweep, mark assist, STW, how GC gets triggered, etc}]
    \stopsubsection
  \stopsection

  \startsection[title=The runtime's goroutines]
    The runtime spawns several of its own goroutines that will show up in most traces.
    Most of these exist to help with the concurrent garbage collector.

    \startitemize
    \item \code{bgsweep} is a low priority goroutine that sweeps spans when there are idle Ps. This reduces the amount
      of sweeping that has to be done by other goroutines.
    \item \todo{bgscavenger}
    \item \todo{gcBgMarkWorker}
    \item \code{forcegchelper} periodically gets woken up and forces a garbage collection cycle to start.
      This ensures that garbage gets collected regularly even if the program isn't allocating enough memory to hit the heap target.
    \item \code{runfinq} is the goroutine that is responsible for running finalizers.
      That means that this runtime goroutine will execute code provided by the user via \code{runtime.SetFinalizer}.
      \intodo{fix line wrapping}
    \stopitemize

  \stopsection

\stopchapter

\startchapter[reference=cpu-sampling, title=CPU sampling]
  \intodo{We probably want to move this chapter into a subchapter of the UI chapter}
  In addition to sequences of runtime events and user regions, Gotraceui can also display tracks of stack traces.
  Such tracks can help spot macroscopic patterns in code execution. They are reconstructed from CPU profiling
  samples as well as the stacks associated with certain runtime events and thus have a sampled, imprecise nature.

  \midaligned{\clip[width=0.95\textwidth]{\externalfigure[images/screenshots/stack_samples.png]}}

  It is important to understand the nature and limitations of the data displayed in these tracks. Strictly
  speaking, each CPU profiling sample and each runtime event describes an instant in time, not a duration. However, in
  our reconstruction, we connect consecutive stack traces, making it look like a function has been running for the
  entire duration between two events or samples. This is a lie.

  A CPU profiling sample states that at a specific point in time, a certain function was executing. It doesn't say
  anything about what happened right after the sample. By default, samples occur at a frequency of \unit{100 Hz}, i.e.
  once every \unit{10 ms}. This means that there is \unit{10 ms} of uncertainty after a sample. The function might've
  returned anywhere from \unit{0} to \unit{10 ms} after the sample. It may even have been called repeatedly. All we really
  know is that at one point in time, the function was running.

  Nevertheless, when looking at larger scales (hundreds of milliseconds, if not seconds), especially when looking at
  repetitive executions, this visualization can expose patterns. The more often the same stack gets sampled, the more
  likely it is that it is indeed a major contributor to the code's execution. However, the data is woefully inadequate
  at small scales — the kind of scales at which runtime trace data exists. You shouldn't rely on the sampled stack
  traces to fill in the gaps between two runtime events that happened \unit{100 us} apart.

  Gotraceui combines both CPU profiling and some runtime events when reconstructing stack trace tracks. CPU
  samples are those used by pprof. Beginning with Go 1.19, runtime traces include CPU samples if profiling is enabled
  at the same time as tracing. However, goroutines that are blocked don't receive any samples, so we additionally use
  the stacks associated with runtime events that signal state transitions, such as goroutines calling
  \code{time.Sleep}, to fill in the gaps. This way, the last stack before a potentially long time without samples will
  be as accurate as possible.

  Using sampling and runtime events together further affects how you should treat durations in stack traces
  because of the following two reasons:

  \startitemize[n]
  \item We've already established that span durations derived from samples aren't accurate, but this is even more
    pronounced when trying to look at runtime events and the corresponding reconstructed tracks together. For
    example, when we enter the \quote{blocked on channel send} state, we will display the stack associated with that
    event, until we get the next stack. This means, however, that even after we unblock and go back to the
    \quote{ready} and \quote{active} states, the stack will not update, as neither event contains a new stack. This
    will make it look like we're still in the \code{runtime.chansend} function even after we've completed the channel
    send. Only on the next sample or relevant event will the stack update. It is therefore important to either look at
    runtime events or the stacks, but not both together. Runtime events show an exact history of what happened in
    the runtime, while stacks show a guess at what happened in user code.

  \item CPU profiling samples happen at a fairly constant rate, which means all samples have the same uncertainty.
    Runtime events, however, can happen at arbitrary points. If a sample is followed by a runtime event \unit{1 ms}
    later then it will look much smaller than if it were followed by a runtime event \unit{9 ms} later, even though in
    the latter case we still don't know what happened for the first \unit{9 ms}. This is another instance of span
    durations of samples not having much meaning.
  \stopitemize

  Gotraceui doesn't use the stacks of other events, such as syscalls, because this would lead to bias in the data.
  Samples are evenly distributed and – on average – lead to a fair representation of a program's execution, and
  considering state transitions is necessary, as we have explained earlier. Including other events, on the other hand,
  would skew the displayed stacks towards those events.
\stopchapter

\stoptext
